

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Welcome to qcware’s documentation! &mdash; qcware  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="#" class="icon icon-home"> qcware
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Welcome to qcware’s documentation!</a><ul>
<li><a class="reference internal" href="#module-qcware.optimization">Optimization</a></li>
<li><a class="reference internal" href="#module-qcware.physics">Physics</a></li>
<li><a class="reference internal" href="#module-qcware.qml">QML</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">qcware</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="#">Docs</a> &raquo;</li>
        
      <li>Welcome to qcware’s documentation!</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="welcome-to-qcware-s-documentation">
<h1>Welcome to qcware’s documentation!<a class="headerlink" href="#welcome-to-qcware-s-documentation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-qcware.optimization">
<span id="optimization"></span><h2>Optimization<a class="headerlink" href="#module-qcware.optimization" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="qcware.optimization.SolveBinaryWarning">
<em class="property">exception </em><code class="sig-prename descclassname">qcware.optimization.</code><code class="sig-name descname">SolveBinaryWarning</code><a class="headerlink" href="#qcware.optimization.SolveBinaryWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Warning type for warnings from <a class="reference internal" href="#qcware.optimization.solve_binary" title="qcware.optimization.solve_binary"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qcware.optimization.solve_binary</span></code></a>.</p>
<p>Initiate warning with <code class="xref py py-obj docutils literal notranslate"><span class="pre">SolveBinaryWarning.warn(&quot;message&quot;)</span></code>.</p>
<dl class="method">
<dt id="qcware.optimization.SolveBinaryWarning.warn">
<em class="property">classmethod </em><code class="sig-name descname">warn</code><span class="sig-paren">(</span><em class="sig-param">message</em><span class="sig-paren">)</span><a class="headerlink" href="#qcware.optimization.SolveBinaryWarning.warn" title="Permalink to this definition">¶</a></dt>
<dd><p>Warn with cls at a default level.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>message (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>): message to show with the warning.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="qcware.optimization.SolverWarning">
<em class="property">exception </em><code class="sig-prename descclassname">qcware.optimization.</code><code class="sig-name descname">SolverWarning</code><a class="headerlink" href="#qcware.optimization.SolverWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Warning type for solver related warnings in <cite>qcware.optimization.solve_binary</cite>.</p>
<p>Initiate warning with <code class="xref py py-obj docutils literal notranslate"><span class="pre">SolverWarning.warn(&quot;message&quot;)</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="qcware.optimization.enumerate_Q">
<code class="sig-prename descclassname">qcware.optimization.</code><code class="sig-name descname">enumerate_Q</code><span class="sig-paren">(</span><em class="sig-param">Q</em><span class="sig-paren">)</span><a class="headerlink" href="#qcware.optimization.enumerate_Q" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace the keys of Q with an enumeration of the input variables.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>Q (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code>): A dictionary representation of <span class="math notranslate nohighlight">\(Q\)</span> where the keys are tuples of ints or strings</p>
</dd>
<dt>Returns:</dt><dd><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code>: A dictionary representation of <span class="math notranslate nohighlight">\(Q\)</span> where the keys are ints
<code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code>: A dictionary mapping those ints to the original key values
<code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code>: A dictionary mapping those the original key values to those ints</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qcware.optimization.ising_to_qubo">
<code class="sig-prename descclassname">qcware.optimization.</code><code class="sig-name descname">ising_to_qubo</code><span class="sig-paren">(</span><em class="sig-param">h</em>, <em class="sig-param">J</em>, <em class="sig-param">offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#qcware.optimization.ising_to_qubo" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the specified Ising problem into a QUBO problem.
Note that Ising {-1, 1} values go to QUBO {0, 1} values in that order!</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>h (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code>): Field values.</dt><dd><p>The field of each spin in the Ising formulation.
<cite>h[i]</cite> is the field value for the ith spin.</p>
</dd>
<dt>J (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code>): Coupling values.</dt><dd><p><cite>J[(i, j)]</cite> is the coupling between the ith and jth spin. Note
that <cite>J</cite> cannot have a key that has a repeated index, ie <cite>(1, 1)</cite> is an
invalid key.</p>
</dd>
<dt>offset (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, optional): Defaults to 0.</dt><dd><p>It is the sum of the terms in the formulation that don’t involve any variables.</p>
</dd>
</dl>
</dd>
<dt>Return:</dt><dd><dl class="simple">
<dt>result (<code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code>): (Q, offset).</dt><dd><dl class="simple">
<dt>Q (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code>): QUBO dictionary.</dt><dd><p>Maps tuples of binary variables indices to the Q value.
ie <cite>Q[(i, j)]</cite> is the <cite>(i, j)</cite> QUBO value.</p>
</dd>
<dt>offset (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>): Numeric.</dt><dd><p>The part of the objective function that does not depend on the
variables.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qcware.optimization.ising_value">
<code class="sig-prename descclassname">qcware.optimization.</code><code class="sig-name descname">ising_value</code><span class="sig-paren">(</span><em class="sig-param">z</em>, <em class="sig-param">h</em>, <em class="sig-param">J</em>, <em class="sig-param">offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#qcware.optimization.ising_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the value of the Ising objective function for a given spin configuration.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>z (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">iterable</span></code>): spin configuration.</dt><dd><p>Maps variable labels to their values, -1 or 1. Ie <cite>z[i]</cite> must be the
value of variable i.</p>
</dd>
<dt>J (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code>): Coupling dictionary.</dt><dd><p>Maps pairs of variables labels to the J value.</p>
</dd>
<dt>h (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code>): Field dictionary.</dt><dd><p>Maps variable names to their field value.</p>
</dd>
<dt>offset (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, optional): Defaults to 0.</dt><dd><p>The part of the objective function that does not depend on the
variables.</p>
</dd>
</dl>
</dd>
<dt>Return:</dt><dd><p>value (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>): The value of the Ising with the given assignment <cite>z</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qcware.optimization.mat_to_dict">
<code class="sig-prename descclassname">qcware.optimization.</code><code class="sig-name descname">mat_to_dict</code><span class="sig-paren">(</span><em class="sig-param">mat</em><span class="sig-paren">)</span><a class="headerlink" href="#qcware.optimization.mat_to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a numpy array representing <span class="math notranslate nohighlight">\(Q\)</span> to a dictionary of the appropriate format.</p>
<p>This function takes a numpy matrix representation of a <span class="math notranslate nohighlight">\(Q\)</span> matrix and converts it to a spare representation
using the built-in Python dictionary datatype.  Matrix indices are encoded as keys (paris of ints).  Matrix entries
are encoded as values in the dictionary.  <span class="math notranslate nohighlight">\(Q\)</span> is assumed to be symmetric.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mat (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.array</span></code>): A 2D numpy array (like a matrix) representing the <span class="math notranslate nohighlight">\(Q\)</span> matrix associated with the</dt><dd><p>objective function of the optimization problem being solved.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code>: A dictionary representation of <span class="math notranslate nohighlight">\(Q\)</span> that can be sent to the platform.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qcware.optimization.qubo_to_ising">
<code class="sig-prename descclassname">qcware.optimization.</code><code class="sig-name descname">qubo_to_ising</code><span class="sig-paren">(</span><em class="sig-param">Q</em>, <em class="sig-param">offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#qcware.optimization.qubo_to_ising" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the specified QUBO problem into an Ising problem.
Note that QUBO {0, 1} values go to Ising {-1, 1} values in that order!</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>Q (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code>): QUBO dictionary.</dt><dd><p>Maps tuples of binary variables indices to the Q value.
ie <cite>Q[(i, j)]</cite> is the <cite>(i, j)</cite> QUBO value.</p>
</dd>
<dt>offset (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, optional): defaults to 0.</dt><dd><p>The part of the objective function that does not depend on the
variables.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>result (<a href="#id1"><span class="problematic" id="id2">:object:`tuple`</span></a>): (h, J, offset).</dt><dd><dl class="simple">
<dt>h (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code>): Field values.</dt><dd><p>The field of each spin in the Ising formulation.
<cite>h[i]</cite> is the field value for the ith spin.</p>
</dd>
<dt>J (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code>): Coupling values.</dt><dd><p><cite>J[(i, j)]</cite> is the coupling between the ith and jth spin.</p>
</dd>
<dt>offset<span class="classifier">float.</span></dt><dd><p>The sum of the terms in the formulation that don’t involve any variables.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qcware.optimization.qubo_value">
<code class="sig-prename descclassname">qcware.optimization.</code><code class="sig-name descname">qubo_value</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">Q</em>, <em class="sig-param">offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#qcware.optimization.qubo_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the value of the QUBO objective function for a given bit string.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>x (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">iterable</span></code>): Bit string.</dt><dd><p>Maps binary variable indices to their binary values, 0 or 1. Ie
<cite>x[i]</cite> must be the binary value of variable i.</p>
</dd>
<dt>Q (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code>): QUBO dictionary.</dt><dd><p>Maps tuples of binary variables indices to the Q value.</p>
</dd>
<dt>offset (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, optional): Defaults to 0.</dt><dd><p>The part of the objective function that does not depend on the
variables.</p>
</dd>
</dl>
</dd>
<dt>Return:</dt><dd><p>value (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>): The value of the QUBO with the given assignment <cite>x</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qcware.optimization.solve_binary">
<code class="sig-prename descclassname">qcware.optimization.</code><code class="sig-name descname">solve_binary</code><span class="sig-paren">(</span><em class="sig-param">key</em>, <em class="sig-param">Q</em>, <em class="sig-param">solver='dwave_hw'</em>, <em class="sig-param">constraints_linear_A=[]</em>, <em class="sig-param">constraints_linear_b=[]</em>, <em class="sig-param">constraints_sat_max_runs=3100</em>, <em class="sig-param">constraints_hard=False</em>, <em class="sig-param">constraints_penalty_scaling_factor=1</em>, <em class="sig-param">constraints_equality_R=[]</em>, <em class="sig-param">constraints_equality_c=[]</em>, <em class="sig-param">constraints_inequality_S=[]</em>, <em class="sig-param">constraints_inequality_d=[]</em>, <em class="sig-param">return_all_solutions=False</em>, <em class="sig-param">num_runs=50</em>, <em class="sig-param">dwave_algorithm=None</em>, <em class="sig-param">dwave_solver_limit=None</em>, <em class="sig-param">dwave_target_energy=None</em>, <em class="sig-param">dwave_find_max=None</em>, <em class="sig-param">dwave_reduce_intersample_correlation=None</em>, <em class="sig-param">dwave_num_spin_reversal_transforms=None</em>, <em class="sig-param">dwave_programming_thermalization=None</em>, <em class="sig-param">dwave_reinitialize_state=None</em>, <em class="sig-param">dwave_anneal_offsets=None</em>, <em class="sig-param">dwave_anneal_offsets_delta=None</em>, <em class="sig-param">dwave_num_reads=None</em>, <em class="sig-param">dwave_max_answers=None</em>, <em class="sig-param">dwave_flux_biases=None</em>, <em class="sig-param">dwave_beta=None</em>, <em class="sig-param">dwave_answer_mode=None</em>, <em class="sig-param">dwave_auto_scale=None</em>, <em class="sig-param">dwave_postprocess=None</em>, <em class="sig-param">dwave_annealing_time=None</em>, <em class="sig-param">dwave_anneal_schedule=None</em>, <em class="sig-param">dwave_initial_state=None</em>, <em class="sig-param">dwave_chains=None</em>, <em class="sig-param">dwave_flux_drift_compensation=None</em>, <em class="sig-param">dwave_beta_range=None</em>, <em class="sig-param">dwave_num_sweeps=None</em>, <em class="sig-param">dwave_precision_ancillas=None</em>, <em class="sig-param">dwave_precision_ancillas_tuples=None</em>, <em class="sig-param">constraints_hard_num=4</em>, <em class="sig-param">sa_num_sweeps=200</em>, <em class="sig-param">use_sample_persistence=False</em>, <em class="sig-param">sample_persistence_solution_threshold=0.5</em>, <em class="sig-param">sample_persistence_persistence_threshold=0.5</em>, <em class="sig-param">sample_persistence_persistence_iterations=0</em>, <em class="sig-param">google_num_steps=1</em>, <em class="sig-param">google_n_samples=1000</em>, <em class="sig-param">google_arguments_optimizer={}</em>, <em class="sig-param">google_step_sampling=True</em>, <em class="sig-param">google_n_samples_step_sampling=1000</em>, <em class="sig-param">number_of_blocks=1</em>, <em class="sig-param">iterations=50</em>, <em class="sig-param">initial_solution=None</em>, <em class="sig-param">always_update_with_best=True</em>, <em class="sig-param">update_q_each_block_solution=True</em>, <em class="sig-param">host='https://forge.qcware.com'</em><span class="sig-paren">)</span><a class="headerlink" href="#qcware.optimization.solve_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a binary optimization problem using one of the solvers provided by the platform.</p>
<dl class="simple">
<dt>This function solves a binary optimization problem that is either:</dt><dd><ul class="simple">
<li><p>Unconstrained (quadratic or higher order)</p></li>
<li><p>Linearly and/or quadratically Constrained (quadratic)</p></li>
</ul>
</dd>
</dl>
<p>Constraints may be linear or quadratic.  Specifically, the function is capable of solving a function of the form</p>
<div class="math notranslate nohighlight">
\[\begin{split}\min_x x^T Q x \\
\text{such that} \\
Ax = b \\
x^T R_i x = c_i \\
x^T S_i x \geq d_i \\\end{split}\]</div>
<p>Here, <span class="math notranslate nohighlight">\(x\)</span> is a length-<span class="math notranslate nohighlight">\(n\)</span> vector of binary values, i.e., <span class="math notranslate nohighlight">\(\{0,1\}^n\)</span> (this is what the solver
finds).  <span class="math notranslate nohighlight">\(Q\)</span> is a <span class="math notranslate nohighlight">\((n\times n)\)</span> matrix of reals.  <span class="math notranslate nohighlight">\(A\)</span> is a <span class="math notranslate nohighlight">\((m \times n)\)</span> matrix of reals
(partially specifying <span class="math notranslate nohighlight">\(m\)</span> different linear constraints).  <span class="math notranslate nohighlight">\(b\)</span> is a length-<span class="math notranslate nohighlight">\(m\)</span> vector of reals
(specifying the other component of <cite>m</cite> different linear constraints).  Every <span class="math notranslate nohighlight">\(R_i\)</span> and <span class="math notranslate nohighlight">\(S_i\)</span> is a
<span class="math notranslate nohighlight">\((n \times n)\)</span> matrix of reals, and every <span class="math notranslate nohighlight">\(c_i\)</span> and <span class="math notranslate nohighlight">\(d_i\)</span> is a real constant.  The
<span class="math notranslate nohighlight">\((R_i, c_i)\)</span> pairs specify quadratic equality constraints, and the <span class="math notranslate nohighlight">\((S_i, d_i)\)</span> pairs specify
quadratic inequality constraints.</p>
<dl class="simple">
<dt>In the simplest case, the only variables required to be passed to this function are a valid access key for the platform and a dictionary representing a QUBO.  Additional options are available to:</dt><dd><ul class="simple">
<li><p>Specify constraints for a problem</p></li>
<li><p>Select different solvers (note: different accounts have different solvers available)</p></li>
<li><p>Specify solver-specific parameters</p></li>
</ul>
</dd>
</dl>
<p>Error handling is provided by the platform, and warnings and errors that are detected while attempting to run a
problem are returned in the JSON object returned by this function.</p>
<p>Possible warnings include:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 83%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Warning Code</p></th>
<th class="head"><p>Warning Message</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>7</p></td>
<td><p>Precision required not supported by the machine, still proceeding.</p></td>
</tr>
<tr class="row-odd"><td><p>10</p></td>
<td><p>Hardware solver failed, solving in software solver.</p></td>
</tr>
<tr class="row-even"><td><p>22</p></td>
<td><p>Automatic parameter setting failed; solving using default values.</p></td>
</tr>
</tbody>
</table>
<p>Possible errors include:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Error Code</p></th>
<th class="head"><p>Error Message</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>6</p></td>
<td><p>Integer formulation for HFS not found.</p></td>
</tr>
<tr class="row-odd"><td><p>11</p></td>
<td><p>D-Wave hardware solver returned error.</p></td>
</tr>
<tr class="row-even"><td><p>100</p></td>
<td><p>Invalid solver selected.</p></td>
</tr>
</tbody>
</table>
<p>It is strongly recommended to wrap a call to <a class="reference internal" href="#qcware.optimization.solve_binary" title="qcware.optimization.solve_binary"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_binary</span></code></a> in a try/catch block since it is possible for the
platform or the client library to raise an exception.</p>
<dl>
<dt>Args:</dt><dd><p>key (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>): An API key for the platform.  Keys can be allocated and managed from the Forge web portal.</p>
<dl>
<dt>Q (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code>): The objective function matrix in the optimization problem described above.  In the case of a</dt><dd><p>quadratic problem, this is a 2D matrix; generally, in the case of higher-order problems, this is an
<span class="math notranslate nohighlight">\(n\)</span>-dimensional matrix (a tensor).</p>
<p>Since <span class="math notranslate nohighlight">\(Q\)</span> is usually sparse, <span class="math notranslate nohighlight">\(Q\)</span> should be specified
as a Python dictionary with integer or string pairs <span class="math notranslate nohighlight">\((i,j)\)</span> as keys (representing the <span class="math notranslate nohighlight">\((i,j)\)</span>) and integer or float values.  In the case of a cubic function, for example, some
dictionary keys will be 3-tuples of integers, rather than pairs.</p>
<p>Alternatively, <span class="math notranslate nohighlight">\(Q\)</span> may be specified as a numpy array or list, in which case <a class="reference internal" href="#qcware.optimization.mat_to_dict" title="qcware.optimization.mat_to_dict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mat_to_dict</span></code></a> is called on
<span class="math notranslate nohighlight">\(Q\)</span> before sending it to the platform.  Note that that helper function assumes <span class="math notranslate nohighlight">\(Q\)</span> is symmetric,
which may not be true in general. It is strongly encouraged to format <span class="math notranslate nohighlight">\(Q\)</span> is a dictionary.</p>
</dd>
</dl>
<p>solver (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>, optional): The name of the solver to use for the given problem.  Valid values are:</p>
<blockquote>
<div><ul class="simple">
<li><p>“dwave_hw”: Run on a physical D-Wave machine</p></li>
<li><p>“brute_force”: Run using a brute force algorithm</p></li>
<li><p>“hfs”: Run using the Hamze-de Freitas-Selby algorithm</p></li>
<li><p>“google_sw_qaoa”: Run using the Google simulator implementation of the QAOA algorithm</p></li>
<li><p>“ibm_hw_qaoa”: Run the QAOA algorithm on a physical IBM machine, this may take over 2 hours for even small problems!</p></li>
<li><p>“ibm_sw_qaoa”: Run the QAOA algorithm on IBM’s software simulator of the QAOA algorithm</p></li>
</ul>
<p>Note that only certain solvers may be enabled depending on your account.  Default value “dwave_hw”.</p>
</div></blockquote>
<dl class="simple">
<dt>constraints_linear_A (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>, optional): The <span class="math notranslate nohighlight">\(A\)</span> matrix for specifying linear constraints.  <span class="math notranslate nohighlight">\(A\)</span></dt><dd><p>should be formatted as a two-dimensional Python list.  Default value <code class="xref py py-obj docutils literal notranslate"><span class="pre">[]</span></code>.</p>
</dd>
<dt>constraints_linear_b (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>, optional): The <span class="math notranslate nohighlight">\(b\)</span> vector for specifying linear constraints.  <span class="math notranslate nohighlight">\(b\)</span></dt><dd><p>should be formatted as a one-dimensional Python list.  Default value <code class="xref py py-obj docutils literal notranslate"><span class="pre">[]</span></code>.</p>
</dd>
<dt>constraints_sat_max_runs (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional): The maximum number of iterations the platform should run in</dt><dd><p>order to find a formulation where all constraints are satisfied.  Default value <code class="xref py py-obj docutils literal notranslate"><span class="pre">3100</span></code>.</p>
</dd>
<dt>constraints_hard (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, optional): Whether to strictly enforce all constraints; if <code class="xref py py-obj docutils literal notranslate"><span class="pre">False</span></code>,</dt><dd><p>constraint penalties may be low enough such that constraints are violated, with the benefit of an improved
energy landscape.  Default value <code class="xref py py-obj docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
<dt>constraints_penalty_scaling_factor (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional): An extra constant scaling factor for the Lagrange</dt><dd><p>multipliers associated with the penalty terms for the constraints.  This may be helpful if constraints are
being violated too much or too often.  Default value 1.</p>
</dd>
<dt>constraints_equality_R (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>, optional): The <span class="math notranslate nohighlight">\(R\)</span> matrices for specifying quadratic equality</dt><dd><p>constraints.  <span class="math notranslate nohighlight">\(R\)</span> should be formatted as a list of two-dimensional lists (i.e., a list of matrices).
Default value <code class="xref py py-obj docutils literal notranslate"><span class="pre">[]</span></code>.</p>
</dd>
<dt>constraints_equality_c (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>, optional): The <span class="math notranslate nohighlight">\(c\)</span> vectors for specifying quadratic equality</dt><dd><p>constraints.  <span class="math notranslate nohighlight">\(c\)</span> should be formatted as a list of one-dimensional Python lists (i.e., a list of
vectors).  Default value <code class="xref py py-obj docutils literal notranslate"><span class="pre">[]</span></code>.</p>
</dd>
<dt>constraints_inequality_S (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>, optional): The <span class="math notranslate nohighlight">\(S\)</span> matrices for specifying quadratic inequality</dt><dd><p>constraints.  <span class="math notranslate nohighlight">\(S\)</span> should be formatted as a list of two-dimensional lists (i.e., a list of matrices).
Default value <code class="xref py py-obj docutils literal notranslate"><span class="pre">[]</span></code>.</p>
</dd>
<dt>constraints_inequality_d (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>, optional): The <span class="math notranslate nohighlight">\(d\)</span> vectors for specifying quadratic inequality</dt><dd><p>constraints.  <span class="math notranslate nohighlight">\(d\)</span> should be formatted as a list of one-dimensional Python lists (i.e., a list of
vectors).  Default value <code class="xref py py-obj docutils literal notranslate"><span class="pre">[]</span></code>.</p>
</dd>
<dt>return_all_solutions (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, optional): Whether to return all the candidate solutions found for a problem;</dt><dd><p>if <code class="xref py py-obj docutils literal notranslate"><span class="pre">False</span></code>, the platform will only return the solution corresponding to the lowest energy found.
Default value <code class="xref py py-obj docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
<dt>num_runs (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional): The number of iterations to run with the selected solver.  Default value</dt><dd><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">50</span></code>.</p>
</dd>
</dl>
<p>dwave_reduce_intersample_correlation (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, optional): D-Wave hardware system parameter. See <a class="reference external" href="https://docs.dwavesys.com/docs/latest/c_solver_1.html#reduce-intersample-correlation">reduce_intersample_correlation</a>.</p>
<p>dwave_num_spin_reversal_transforms (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional): D-Wave hardware system parameter. See <a class="reference external" href="https://docs.dwavesys.com/docs/latest/c_solver_1.html#num-spin-reversal-transforms">num_spin_reversal_transforms</a>.</p>
<p>dwave_programming_thermalization (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional): D-Wave hardware system parameter. See <a class="reference external" href="https://docs.dwavesys.com/docs/latest/c_solver_1.html#programming-thermalization">programming_thermalization</a>.</p>
<p>dwave_reinitialize_state (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, optional): D-Wave hardware system parameter. See <a class="reference external" href="https://docs.dwavesys.com/docs/latest/c_solver_1.html#reinitialize-state">reinitialize_state</a>.</p>
<p>dwave_anneal_offsets (<code class="xref py py-obj docutils literal notranslate"><span class="pre">[float]</span></code>, optional): D-Wave hardware system parameter. See <a class="reference external" href="https://docs.dwavesys.com/docs/latest/c_solver_1.html#anneal-offsets">anneal_offsets</a>.</p>
<p>dwave_anneal_offsets_delta: (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, optional): Parameter greater or equal to 0 that is used to generate anneal offsets, cannot be specified if dwave_anneal_offsets is also specified. We recommend the value to be in [0, 0.05]. See <a class="reference external" href="https://arxiv.org/pdf/1806.11091.pdf">https://arxiv.org/pdf/1806.11091.pdf</a>.</p>
<p>dwave_num_reads (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional): D-Wave hardware system parameter. See <a class="reference external" href="https://docs.dwavesys.com/docs/latest/c_solver_1.html#num-reads">num_reads</a>.</p>
<p>dwave_max_answers (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional): D-Wave hardware system parameter. See <a class="reference external" href="https://docs.dwavesys.com/docs/latest/c_solver_1.html#max-answers">max_answers</a>.</p>
<p>dwave_flux_biases (<code class="xref py py-obj docutils literal notranslate"><span class="pre">[float]</span></code>, optional): D-Wave hardware system parameter. See <a class="reference external" href="https://docs.dwavesys.com/docs/latest/c_solver_1.html#flux-biases">flux_biases</a>.</p>
<p>dwave_beta (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, optional): D-Wave hardware system parameter. See <a class="reference external" href="https://docs.dwavesys.com/docs/latest/c_solver_1.html#beta">beta</a>.</p>
<p>dwave_answer_mode (<code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>, optional): D-Wave hardware system parameter. See <a class="reference external" href="https://docs.dwavesys.com/docs/latest/c_solver_1.html#answer-mode">answer_mode</a>.</p>
<p>dwave_auto_scale (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, optional): D-Wave hardware system parameter. See <a class="reference external" href="https://docs.dwavesys.com/docs/latest/c_solver_1.html#auto-scale">auto_scale</a>.</p>
<p>dwave_postprocess (<code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>, optional): D-Wave hardware system parameter. See <a class="reference external" href="https://docs.dwavesys.com/docs/latest/c_solver_1.html#postprocess">postprocess</a>.</p>
<p>dwave_annealing_time (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional): D-Wave hardware system parameter. See <a class="reference external" href="https://docs.dwavesys.com/docs/latest/c_solver_1.html#annealing-time">annealing_time</a>.</p>
<p>dwave_anneal_schedule (<code class="xref py py-obj docutils literal notranslate"><span class="pre">[(int,</span> <span class="pre">float)]</span></code>, optional): D-Wave hardware system parameter. See <a class="reference external" href="https://docs.dwavesys.com/docs/latest/c_solver_1.html#anneal-schedule">anneal_schedule</a>.</p>
<p>dwave_initial_state (<code class="xref py py-obj docutils literal notranslate"><span class="pre">[(int,</span> <span class="pre">int)]</span></code>, optional): D-Wave hardware system parameter. See <a class="reference external" href="https://docs.dwavesys.com/docs/latest/c_solver_1.html#initial-state">initial_state</a>.</p>
<p>dwave_chains (<code class="xref py py-obj docutils literal notranslate"><span class="pre">[[int]]</span></code>, optional): D-Wave hardware system parameter. See <a class="reference external" href="https://docs.dwavesys.com/docs/latest/c_solver_1.html#chains">chains</a>.</p>
<p>dwave_flux_drift_compensation (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, optional): D-Wave hardware system parameter. See <a class="reference external" href="https://docs.dwavesys.com/docs/latest/c_solver_1.html#flux-drift-compensation">flux_drift_compensation</a>.</p>
<p>dwave_beta_range (<code class="xref py py-obj docutils literal notranslate"><span class="pre">[int]</span></code>, optional): D-Wave software system parameter. See <a class="reference external" href="https://docs.ocean.dwavesys.com/projects/dimod/en/latest/reference/generated/dimod.reference.samplers.SimulatedAnnealingSampler.sample.html">beta_range</a>.</p>
<p>dwave_num_sweeps (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional): D-Wave software system parameter. See <a class="reference external" href="https://docs.ocean.dwavesys.com/projects/dimod/en/latest/reference/generated/dimod.reference.samplers.SimulatedAnnealingSampler.sample.html">num_sweeps</a>.</p>
<p>dwave_precision_ancillas (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, optional):</p>
<p>dwave_precision_ancillas_tuples (<code class="xref py py-obj docutils literal notranslate"><span class="pre">[[int]]</span></code>, optional):</p>
<p>constraints_hard_num (<code class="xref py py-obj docutils literal notranslate"><span class="pre">[[int]]</span></code>, optional):</p>
<dl class="simple">
<dt>sa_num_sweeps (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional): If using a simulated annealing solver, how many sweeps to perform per</dt><dd><p>run of the algorithm.  Default value <code class="xref py py-obj docutils literal notranslate"><span class="pre">200</span></code>.</p>
</dd>
<dt>use_sample_persistence (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, optional): Whether to use the sample persistence method of</dt><dd><p><a class="reference external" href="https://arxiv.org/abs/1606.07797">https://arxiv.org/abs/1606.07797</a> , which aims to improve the probability of a quantum annealer to obtain
an optimal solution.</p>
</dd>
<dt>sample_persistence_solution_threshold (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, optional): A threshold that is used to filter out</dt><dd><p>higher-energy candidate solutions from the sample persistence method.  A percentage that ranges from 0 to 1.</p>
</dd>
<dt>sample_persistence_persistence_threshold (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, optional): A threshold between 0 and 1 such that a</dt><dd><p>variable is fixed if its mean absolute value across the filtered sample is larger than the value of the
threshold.  Called fixing_threshold in the original paper.</p>
</dd>
<dt>sample_persistence_persistence_iterations (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional): The number of iterations to run the sample</dt><dd><p>persistence algorithm.  Generally speaking, more iterations will make the algorithm more successful, at
the cost of increased computation time.</p>
</dd>
<dt>google_num_steps (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional): The number of QAOA steps implemented</dt><dd><p>by the algorithm.  Default value <code class="xref py py-obj docutils literal notranslate"><span class="pre">1</span></code>.</p>
</dd>
<dt>google_n_samples (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional): The number of runs corresponding to</dt><dd><p>the final sampling step.  Default value <code class="xref py py-obj docutils literal notranslate"><span class="pre">1000</span></code>.</p>
</dd>
<dt>google_arguments_optimizer (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code>, optional): The dictionary that contains the parameters</dt><dd><p>of the bayesain-optimization optimizer.  Default value <code class="xref py py-obj docutils literal notranslate"><span class="pre">{'init_point':</span> <span class="pre">10,</span> <span class="pre">'number_iter':</span> <span class="pre">20,</span> <span class="pre">'kappa':</span> <span class="pre">2}</span></code>.</p>
</dd>
<dt>google_step_sampling (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, optional): Wheter to sample the circuit with the current parameters</dt><dd><p>at every step of the optimization (True) or just at the final one.  Default value <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
<dt>google_n_samples_step_sampling (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional): The number of runs corresponding to</dt><dd><p>sampling at every step of the optimization.  Default value <code class="xref py py-obj docutils literal notranslate"><span class="pre">1000</span></code>.</p>
</dd>
<dt>number_of_blocks (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional): number of blocks to decompose problem into using</dt><dd><p>random decomposition. Default value :obj: <cite>1</cite> meaning no decomposition.</p>
</dd>
<dt>iterations (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional): number of iterations to cycle through when using</dt><dd><p>random decomposition. Only valid if :obj: <cite>number_of_blocks</cite> is greater than 1.
Each iterations corresponds to solving all blocks of the decomposition once.
Default value <code class="xref py py-obj docutils literal notranslate"><span class="pre">50</span></code>.</p>
</dd>
<dt>initial_solution (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code>, optional): initial solution seed for constructing the</dt><dd><p>blocks using random decomposition. If none is provided, a random solution is
initialized. Default value :obj: <cite>None</cite>. <code class="xref py py-obj docutils literal notranslate"><span class="pre">initial_solution</span></code> should be the same type
as <code class="xref py py-obj docutils literal notranslate"><span class="pre">Q</span></code>.</p>
</dd>
<dt>always_update_with_best (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, optional):  solutions found using decomposition</dt><dd><p>do not monotonically get better with each iterations. The best solution is always returned,
but this flag determines whether or not to construct new decomposition using best solution.
Default value :obj: <cite>True</cite>.</p>
</dd>
<dt>update_q_each_block_solution (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, optional): each blocks decomposed Q matrix</dt><dd><p>can be constructed at the onset of block composition, or updated every time a block is
solved. Default value :obj: <cite>True</cite>.</p>
</dd>
</dl>
<p>host (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>, optional): The AQUA server to which the client library should connect.  Defaults to <a class="reference external" href="https://forge.qcware.com">https://forge.qcware.com</a> .</p>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>JSON object: A JSON object, possibly containing the fields:</dt><dd><ul class="simple">
<li><p>‘solution’ (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code>): A Python dictionary representing the solution vector.  If <code class="xref py py-obj docutils literal notranslate"><span class="pre">return_all_solutions</span></code>
is <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code>, this is a list of dicts. However, if the input <code class="xref py py-obj docutils literal notranslate"><span class="pre">Q</span></code> is a 2D numpy array, then each :obj`solution` will
be a 1D numpy array; if the input <code class="xref py py-obj docutils literal notranslate"><span class="pre">Q</span></code> is a list of lists, then each :obj`solution` will also be a list. :obj`solution`
maps variables labels to their binary values, thus :obj`solution[i]` is the value of the :obj`i`th binary variable.</p></li>
<li><p>‘num_runs’ (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>): How many total runs of the chosen solver were performed in order to produce the
returned solution.</p></li>
<li><p>‘num_qubits’ (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>): How many physical qubits (or simulated qubits, in the case of a software
solver) were used for solving the problem.</p></li>
<li><p>‘num_logical_variables’ (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>): How many logical variables were contained in the problem.</p></li>
<li><p>‘warnings’ (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>): A list of strings containing warning messages from the platform generated when
attempting to solve the problem.  This key does not exist if no warnings were raised.</p></li>
<li><p>‘warning_codes’ (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>): A list of ints containing warning codes from the platform generated when
attempting to solve the problem.  This key does not exist if no warnings were raised.</p></li>
<li><p>‘error’ (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>): A string containing an error message from the platform generated when
attempting to solve the problem.  This key does not exist if no error occurred.</p></li>
<li><p>‘error_code’ (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>): An int containing an error codes from the platform generated when
attempting to solve the problem.  This key does not exist if no error occurred.</p></li>
<li><p>‘extra_info’ (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>): A Python list containing additional information returned by a solver.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qcware.physics">
<span id="physics"></span><h2>Physics<a class="headerlink" href="#module-qcware.physics" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="qcware.physics.find_ground_state_energy">
<code class="sig-prename descclassname">qcware.physics.</code><code class="sig-name descname">find_ground_state_energy</code><span class="sig-paren">(</span><em class="sig-param">key</em>, <em class="sig-param">molecule</em>, <em class="sig-param">minimizer=None</em>, <em class="sig-param">basis='sto-3g'</em>, <em class="sig-param">solver='projectq'</em>, <em class="sig-param">multiplicity=1</em>, <em class="sig-param">charge=0</em>, <em class="sig-param">sampling=False</em>, <em class="sig-param">sampling_trials=1000</em>, <em class="sig-param">guess_amplitudes=[]</em>, <em class="sig-param">initial_state='UCCSD'</em>, <em class="sig-param">host='https://forge.qcware.com'</em><span class="sig-paren">)</span><a class="headerlink" href="#qcware.physics.find_ground_state_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the ground state energy configuration for
input molecular geometry configuration. Energy output is
measured in Hartrees and atomic spacing input is assumed
to be in Angstroms.</p>
<p>This function uses the Variational Quantum Eigensolver and variants
thereof to obtain an estimate for the ground state energy of a molecule
in a given configuration. This is achieved by obtaining the molecular
hamiltonian in second quantized form using standard chemistry packages
(PSI4 and PySCF) using Hartree-Fock theory. The second quantized molecular
hamiltonian is converted into a Qubit Hamiltonian using the jordan-wigner
transformation (in the future, the transformation technique will also
be a parameter specified by the user).</p>
<p>The algorithm then uses a parametrized ansatz, currently restricted to
Unitary Coupled Cluster with Singles and Double excitations (UCCSD), to
prepare a state on the quantum register and estimates the expectation value
of the hamiltonian. The result is fed into a classical optimizer which
determines an update rule for the parametrized ansatz. The returned value
corresponds to the energy and parameters that minimize the energy.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>key (<code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>)<span class="classifier">An API key for the platform.  Keys can be allocated</span></dt><dd><p>and managed from the Forge web portal.</p>
</dd>
<dt>molecule (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>): List of tuples/lists the form</dt><dd><p>[[Element,Position], [Element,Position]]
where Element is the periodic table symbol for atom
and Position is a list [x,y,z] with cartesian coordinates
representing the given atom’s position in the molecular geometry input
assuming Bohr-Oppenheimer approximation that the nuclei are at fixed
coordinates. Distances are assumed to be in angstroms.</p>
</dd>
<dt>minimizer (<code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>): classical optimizer used to minimize</dt><dd><p>parameters in ansatz used for the state preparation. If solver is set to
‘projectq’ minimizer default is ‘swarm’ representing swarming algorithm
and if solver is set to ‘ibm_software’ or ‘ibm_hardware’ default value
is set to ‘cobyla’. More minimizers will be available in the future.</p>
<ul class="simple">
<li><dl class="simple">
<dt>For ‘projectq’ valid minimizers are:</dt><dd><ul>
<li><p>‘CG’ for conjugate gradient</p></li>
<li><p>‘swarm’ for pyswarm implementation of swarming algorithm</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>For ‘ibm_x’ valid minimizers are:</dt><dd><ul>
<li><p>‘cobyla’ Constrained optimization by linear approximation</p></li>
<li><p>‘spsa’ simultaneous perturbation stochastic approximation</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>basis (<code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>, optional): Orbital basis set used in classical</dt><dd><p>computation of molecular hamiltonian. Accepted values are
the ones natively used in psi4 chemistry package. Default value
set to <code class="xref py py-obj docutils literal notranslate"><span class="pre">sto-3g</span></code></p>
</dd>
<dt>solver (<code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>, optional): The name of the solver to use for</dt><dd><p>the given problem.  Valid values are:</p>
<ul class="simple">
<li><p>“projectq”: Run on a physical D-Wave machine</p></li>
<li><p>“ibm_software”: Run on D-Wave’s software simulator</p></li>
<li><p>“ibm_hardware”: Run using a brute force algorithm</p></li>
</ul>
</dd>
<dt>multiplicity (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional): integer setting the spin</dt><dd><p>multiplicity (<span class="math notranslate nohighlight">\(2 M_s+1\)</span>). Default set to 1</p>
</dd>
<dt>charge (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional): integer setting the molecular charge.</dt><dd><p>Default set to 0.</p>
</dd>
<dt>sampling (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, optional): boolean determining whether</dt><dd><p>expectation value of energy will be estimated for sampling from the
prepared state or from directly computing an inner product with the
wavefunction. Applicable only to the <cite>projectq</cite> solver.</p>
</dd>
<dt>sampling_trials (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional): if ‘sampling’ is set to</dt><dd><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code>, then this parameter sets the number of samples
taken to estimate expectation value of each term in the molecular
hamiltonian. Applicable only to the <cite>projectq</cite> solver.</p>
</dd>
<dt>guess_amplitudes (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>, optional): optional list for</dt><dd><p>seeding initialization parameters for the ‘UCCSD’ parametrized state.
Only available for ‘CG’ in ‘projectq’</p>
</dd>
<dt>initial_state (:obj: <cite>string</cite>, optional): Sets the type of parametrized</dt><dd><p>parametrized ansatz used to optimize ground state energy. Default value
set to ‘UCCSD’. Currently only available option, to be expanded in
the future.</p>
</dd>
<dt>host (<code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>, optional): The AQUA server to which the client</dt><dd><p>library should connect.  Defaults to <a class="reference external" href="https://platform.qcware.com">https://platform.qcware.com</a> .</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>JSON object: A JSON object, possibly containing the fields:</dt><dd><ul class="simple">
<li><p>‘solution’ (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>): A Python list representing the solution
found for the ground state energy of input molecule.</p></li>
<li><p>‘params’ (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>): the optimized parameters for the
parametrized ansatz which minimizes the expectation value
of the hamiltonian.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-qcware.qml">
<span id="qml"></span><h2>QML<a class="headerlink" href="#module-qcware.qml" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="qcware.qml.fit_and_predict">
<code class="sig-prename descclassname">qcware.qml.</code><code class="sig-name descname">fit_and_predict</code><span class="sig-paren">(</span><em class="sig-param">key</em>, <em class="sig-param">X=[]</em>, <em class="sig-param">y=[]</em>, <em class="sig-param">T=[]</em>, <em class="sig-param">backend='simulator'</em>, <em class="sig-param">clf_type='nearest_centroids'</em>, <em class="sig-param">clf_params={}</em>, <em class="sig-param">solver='dwave_hw'</em>, <em class="sig-param">host='https://forge.qcware.com'</em><span class="sig-paren">)</span><a class="headerlink" href="#qcware.qml.fit_and_predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Classifies test data according to input training data and a selected backend and classifier type</p>
<p>It is strongly recommended to wrap a call to <a class="reference internal" href="#qcware.qml.fit_and_predict" title="qcware.qml.fit_and_predict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_and_predict</span></code></a> in a try/catch block since it is possible for the
platform or the client library to raise an exception.</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>key (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>): An API key for the platform.  Keys can be allocated and managed from the Forge web portal</dt><dd><p>website.</p>
</dd>
<dt>X (<code class="xref py py-obj docutils literal notranslate"><span class="pre">[[float]]</span></code>): Training data array of dimension m by n, where m equals the number of samples</dt><dd><p>and n the number of features. Both m and n are assumed to be powers of two.</p>
</dd>
<dt>y (<code class="xref py py-obj docutils literal notranslate"><span class="pre">[int]</span></code>): Target values array of dimension 1 by m, where m is the number of rows in X</dt><dd><p>(i.e the number of samples in X). For clf_type = “nearest_clusters”, it is assumed that each target value
has at least two occurences in y.</p>
</dd>
<dt>T (<code class="xref py py-obj docutils literal notranslate"><span class="pre">[[float]]</span></code>): Test data array of dimension d by n, where d is any positive integer</dt><dd><p>and n equals the number of columns in X  (i.e the number of features in X).</p>
</dd>
</dl>
<p>backend (<code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>): Selects the specific backend used to run the computation.</p>
<blockquote>
<div><ul class="simple">
<li><p>“simulator”: Runs the algorithms on a software simulator</p></li>
<li><p>“hardware”: Runs on physical hardware</p></li>
</ul>
<p>Defaults to “simulator”.</p>
</div></blockquote>
<dl>
<dt>clf_type (<code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>): Selects the classifier used to run the computation. Options include</dt><dd><p>“nearest_centroids”, “nearest_clusters”, and “nearest_neighbors”.</p>
<p>Defaults to “nearest_centroids”.</p>
</dd>
</dl>
<p>clf_params (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code>): You can put parameters specific to each classifier here.</p>
<blockquote>
<div><p>The structure of clf_params depends on clf_type and is the following:</p>
<blockquote>
<div><dl class="simple">
<dt>For clf_type = “nearest_centroids”, clf_params is {“mode”: s} is either the string “exact” or the string “sample”.</dt><dd><p>If mode=”sample”, then the classifier samples a centroid with probability propotional to the closeness to the test point.
If mode=”exact”, then multiple samples are taken in order to choose the nearest centroid with high probability.</p>
</dd>
</dl>
<p>For clf_type = “nearest_clusters”, clf_params is the empty dictionary.</p>
<dl class="simple">
<dt>For clf_type = “nearest_neighbors”, clf_params is the dictionary {“k”: n_neighbors}</dt><dd><p>where n_neighbors is the (positive integer) number of nearest neighbours to be computed for each point.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>JSON object: A JSON object, possibly containing the fields:</dt><dd><ul class="simple">
<li><p>‘labels’ (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>): A Python list representing the classification labels.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<div class="toctree-wrapper compound">
</div>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, QC Ware Corp.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>